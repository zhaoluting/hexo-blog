---
title: 你不知道的JavaScript
date: 2021-11-24 12:51:07
tags: book
categories: 读书笔记
---

本文是我阅读[《你不知道的JavaScript》](https://book.douban.com/subject/26854244/)过程中记录下来的笔记。这本我入门前端的时候就买了，买来看了几次，后来就放书架上积灰了。时隔多年，已经忘光了🥲趁这段时间有空又看了一遍，把笔记记了下来。

<!--more-->
# 上卷
## 作用域和闭包
### JavaScript编译
- JavaScript代码片段通常在执行前就进行编译，并且马上执行。
- **传统编译过程（三步）**
  - 分词/词法分析：将由字符串组成的字符串分解成有意义的代码块。这些代码块被称为”词法单元”。
  - 解析/语法分析：将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树（AST）”。
  - 代码生成：将AST转换为可执行代码的过程。
- **编译器**：负责语法分析及代码生成等工作。
- **引擎**：负责整个JavaScript程序的编译及执行过程。
  - **LHS查询**：取到赋值操作的目标。目的是为了对变量进行赋值。
  - **RHS查询**：取到赋值操作的源头。目的是为了获取变量的值。
  - **异常**：
    - 当RHS查询在所有嵌套的作用域中遍寻不到所需的变量，引擎会抛出ReferenceError异常；
    - 当LHS查询在全局作用域也无法找到目标变量，在严格模式下会抛出类似ReferenceError的异常，在非严格模式下会自动创建一个全局变量；
    - 当对通过RHS查询到的变量进行不合理操作时，会抛出TypeError类型的异常，如引用null中的属性。

### 作用域
- 作用域负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。即根据标识符名称查找变量的一套规则。
- **作用域嵌套**：在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，知道找到该变量或抵达全局作用域为止。
- **词法作用域**：JavaScript采用的是词法作用域，定义过程发生在代码的书写阶段，词法作用域由写代码时将变量和块作用域写在哪里决定的。
  - 和另一种动态作用域的区别是，动态作用域是在运行时确定的，关注函数从何处调用，很像this机制。
- **遮蔽效应**：作用域查找会在找到第一个匹配的标识符时停止，所以可以在多层嵌套作用域中定义同名的标识符，内部标识符将“遮蔽”外部标识符。
- **欺骗词法**：在运行时改变词法作用域，但会导致性能下降。均不推荐使用，并且有被严格模式所限制。
  - eval函数：将传入的字符串参数作为代码段来执行，用于执行动态创建的代码。
  - setTimeout、setInterval函数：第一个参数可为字符串，该字符串可被解释为动态生成的函数代码。
  - new function(..)：最后一个参数可为代码字符串，并将其转化为动态生成的函数。
  - with关键字：重复引用同一个对象中的多个属性的快捷方式。本质上是通过将一个对象的引用当做作用域来处理，将对象属性当做作用域中的标识符来处理，从而创建了一个新的词法作用域。
- **函数作用域**：属于这个函数的全部变量都可以在整个函数的范围内使用及复用。
  - **立即执行函数**：能够解决函数名污染所在作用域的问题，并且能够自动运行。有两种书写形式`(function foo(){..})()`、`(function(){..}())`
- **块级作用域**：变量和函数在指定的代码块里（通常是{..}）才能访问。例如with关键字、try/catch、let、const。
- **提升**：所有的声明（变量和函数）都被“移动”到各自作用域的最顶端。
  - JavaScript引擎会将`var a = 2`看成两个声明，第一个是`var a`定义声明在编译阶段进行，第二个是`a = 2`赋值声明被留在原地等待执行。
  - 每个作用域都会进行提升操作，只有声明本身会被提升，包括函数表达式的赋值在内的赋值操作或其他运行逻辑会留在原地。
  - 函数声明和变量声明都会被提升，但函数会被优先提升到普通变量之前

### 作用域闭包
- 当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包。
- **应用**：定时器、事件监听器、AJAX请求、跨窗口通信、Web workers或者任何其他的异步（或同步）任务中，只要使用了回调函数，实际上就是在使用闭包。
- **模块模式必要条件**：必须有外部的封闭函数，该函数必须至少被调用一次；封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。

## this和对象原型
### this关键字
- this是在函数被调用时发生的绑定，它的上下文取决于函数调用时的各种条件，this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。
- **根据绑定规则判断this**：需要直接找到函数的直接调用位置，优先级 new绑定 > 显式绑定 > 隐式绑定 > 默认绑定
  - **new绑定**：函数是否在new中调用？
    - this绑定的是新创建的对象。
    - `var bar = new foo()`
    - 使用`new`来调用函数，或者说发生构造函数调用时，会自动执行以下操作
      - 创建（构造）一个全新的对象；
      - 新对象会被执行`[[prototype]]`连接；
      - 新对象会被绑定到函数对象的this；
      - 如果函数没有返回其他对象，那么`new`表达式中的函数调用会自动返回这个新对象；
  - **显式绑定**：函数是否通过call、apply或者硬绑定（显式绑定的一个变种，this指针不会丢失，如bind）？
    - this绑定的是指定的对象。
    - `var bar = foo.call(obj2)`
  - **隐式绑定**：函数是否在某个上下文对象中调用？
    - this绑定的是那个上下文对象。
    - `var bar = obj1.foo()`
    - 参数传递其实就是一种隐式赋值；调用回调函数的函数可能会修改this。
  - **默认绑定**：都不是的话，使用独立函数调用，即默认绑定
    - 严格模式下绑定到undefined，否则绑定到全局对象。
    - `var bar = foo`
- **this绑定例外**：
  - 把null或者undefined作为this的绑定对象传入call、apply或者bind，这些值在调用时会被忽略，实际应用的是默认绑定规则。常见场景是使用apply来“展开”一个数组并当做参数传入函数，类似地，bind可以对参数进行柯里化（部分求值）。
  - 被创建了“间接引用”的函数会应用默认绑定规则。
  - 软绑定softBind(..)会对指定的函数进行封装，检查调用时的this，如果this绑定到全局对象或者undefined，就把指定的默认对象obj绑定到this，否则不会修改this，防止函数调用应用默认绑定规则，实现了和硬绑定相同的效果，同时保留了隐式绑定或者显式绑定修改this的能力。
- **箭头函数**：不使用this的四种标准规则，而是根据外层（函数或者全局）作用域来决定this，且箭头函数的绑定无法被修改。箭头函数和`self = this`机制一样。


### 对象
- **两种定义形式**：声明（文字）形式和构造形式。二者唯一的区别是文字声明可以添加多个键/值对，构造形式必须逐个添加属性。
- **六种语言类型**：string、number、boolean、null、undefined、object
  - 简单基本类型（string、number、boolean、null、undefined）本身不是对象，`typeof null`会返回“object”是个bug。
    - 不同的对象在底层都表示为二进制，二进制前三位都为0的话会被判断为object类型，null的二进制表示全是0，所以typeof会返回“object”。
  - JavaScript中的函数是“一等公民”，是对象的一个子类型，本质上和普通对象一样（只是可以调用）。
- **内置对象**：对象子类型（注意大写的首字母），String、Number、Boolean、Object、Function、Array、Date、RegExp、Error。
  - 这些内置对象可以当做构造函数来使用，从而构造一个对应子类型的新对象。
  - null和undefined没有对应的构造形式，只有文字形式；Date只有构造没有文字形式。
- **内容**：对象的内容由一些存储在特定命名位置的值组成，称为属性。存储在对象容器内部的是属性的名称，属性名永远是字符串，就像指针一样指向这些值真正的存储位置。
  - **可计算属性名**：ES6新增功能，可以在文字形式中使用`[]`包裹一个表达式来当做属性名。
  - **属性和方法**：函数永远不会“属于”一个对象，即使在对象的文字形式中声明一个函数表达式，这个函数也不会“属于”这个对象，只是对于相同函数对象的多个引用。
  - **复制对象**：
    - `var newObj = JSON.parse(JSON.stringify(someObj))`，需要保证对象是JSON安全的，只适用于部分情况。
    - `object.assign(..)`会遍历一个或多个源对象的所有可枚举的自有键并把它们复制到目标对象，最后返回目标对象，实现浅拷贝。
  - **属性描述符**：从ES5开始所有属性都具备了属性描述符，包含`value`（属性值）、`writable`（控制是否可以修改属性值）、`enumerable`（控制是否会出现在对象的属性枚举中）、`configurale`（控制是否允许配置，修改成false是单项操作无法撤销）特性。
    - 创建普通属性时，属性描述符会使用默认值，也可以使用`Object.defineProperty(..)`来添加一个新属性或者修改一个已有属性并对特性进行设置。
  - **不变性**
    - 对象常量：结合`writable:false`和`configurable:false`就可以创建真正的常量属性（不可修改、重定义或者删除）。
    - 禁止扩展：`Object.preventExtensions(..)`可以禁止一个对象添加新属性并且保留已有属性。
    - 密封：`Object.seal(..)`会创建一个“密封”的对象，在现有对象上调用`Object.preventExtensions(..)`并把所有现有属性标记为`configurable:false`。
    - 冻结：`Object.freeze(..)`会创建一个冻结对象，在现有对象上调用`Object.seal(..)`并把所有“数据访问”属性标记为`writable:false`，这是可以应用在对象上的级别最高的不可变性（不过这个对象引用的其他对象是不受影响的）
  - **[[Get]]和[[Put]]]**：对象默认的[[Get]]和[[Put]]]操作分别可以控制属性值的获取和设置。
  - **Getter和Setter**：getter和setter都是隐藏函数，可以改写默认操作，但是只能应用在单个属性上。
    - getter会在获取属性值时调用，setter会在设置属性值时调用。
    - 当给一个属性定义getter、setter或者两者都有时，这个属性会被定义为“访问描述符”，JavaScript会忽略它们的value和writable特性，取而代之的是关心set、get、configurable和enumerable特性。
    - 通常来说getter和setter是成对出现的。
    - 属性不一定包含值，它们可能是具备getter/setter的“访问描述符”。
  - **存在性**：
    - `"a" in myObject`使用in操作符可以检查属性是否在对象及其`[[Prototype]]`链中。
    - `myObject.hasOwnPrototype("a")`只会检查属性是否存在myObject对象中，不会检查`[[Prototype]]`链。
    - `myObject.prototypeIsEnumerable("a")`可以检查给定的属性名是否直接存在于对象中，而不是在原型链上，并且满足`enumerable:true`。
    - `Object.keys(myObject)`会返回一个数组，包含所有可枚举属性，只会查找对象直接包含的属性。
    - `Object.getOwnPrototypeNames(myObject)`会返回一个数组，包含所有属性，无论它们是否可枚举，只会查找对象直接包含的属性。
  - **遍历**：
    - `for..in`会遍历对象的可枚举属性列表，包括`[[Prototype]]`链。
    - `forEach(..)`会遍历数组中的所有值并忽略回调函数的返回值。
    - `every(..)`会一直运行直到回调函数返回false。
    - `some(..)`会一直运行直到回调函数返回true。
    - `for..of`会直接遍历值而不是数组下标或者对象属性。它首先会向被访问对象请求一个迭代器对象，然后通过调用迭代器对象的next()方法来遍历所有返回值。


### 混合对象“类”
- **类理论**：
  - JavaScript没有类，但提供了一些近似类的语法，js只有对象，可以不通过类直接创建对象。
  - 面向类的设计模式：实例化、继承、（相对）多态。
  - 面向对象编程强调的是数据和操作数据的行为本质上是互相关联的。
  - 多态（在继承链的不同层次名称相同但是功能不同的函数）是类的一个核心概念，父类的通用行为可以被子类用更特殊的行为重写，相对多态性允许从重写行为中引用基础行为。
  - 类实例是由一个特殊的类方法构造的，这个方法名通常和类型相同，被称为构造函数。这个方法的任务就是初始化实例需要的所有信息（状态）。
- **混入**：可以用来模拟类的复制行为，但是通常会产生丑陋并且脆弱的语法，比如显式伪多态`otherObj.methodName.call(this, ...)`。
  - **显式混入**：实际上显式混入并不能完全模拟面向类的语言中的复制，因为对象只能复制引用。
    - `mixin(..)`会遍历sourceObj的属性，如果在targetObj没有这个属性就会进行复制。
    - JavaScript中的函数无法用标准可靠的方法真正的赋值，所以只能复制对共享函数对象的引用。
    - 寄生继承是显式混入模式的一种变体，既是显式又是隐式的。先复制一份父类对象的定义，然后混去子类对象的定义，然后用这个复合对象构建实例。
- **隐式混入**：通过在构造函数调用或者方法调用中使用`Something.cool.call(this)`，借用了Something.cool()在Another的上下文中调用了它（通过this绑定），最终Something.cool()中的赋值操作都会应用在Another对象上而不是Something对象上，这样就把Something的行为混入了Another中。但是要避免使用这种结构，已保证代码的整洁和可维护性。


### 原型
- 所有普通的`[[Prototype]]`链最终都会指向内置的Object.prototype。
- **屏蔽**：
  - 如果属性名foo既出现在myObject中也出现在myObject的`[[Prototype]]`链上层，myObject中包含的foo属性就会屏蔽原型链上层的所有foo属性，myObject.foo总会选择原型链中最底层的foo属性。
  - 如果foo不直接存在于myObject中而是存在于原型链上层时，`myObject.foo = "bar"`会出现的三种情况
    - 如果在`[[Prototype]]`链上层存在名为foo的普通数据访问属性并且没有标记为只读，就会直接在在myObject中添加一个名为foo的新属性，它是屏蔽属性。
    - 如果在`[[Prototype]]`链上层存在foo，但被标记为只读，那么无法修改已有属性或者在myObject上创建屏蔽属性。严格模式下会抛错，否则这条赋值语句会被武略。
    - 如果在`[[Prototype]]`链上层存在foo并且是一个setter，那就会调用这个setter，foo不会被添加到myObject，也不会重新定义foo这个setter。
    - 如果希望在上述的第二和第三种情况下也屏蔽foo，就不能使用=操作符来赋值，而是使用`Object.defineProperty(..)`来向myObject添加foo。
- **“类”函数**：
  - 所有的函数默认都会拥有一个名为prototype的公有并且不可枚举的属性，它会指向Foo的原型。
  - `new Foo()`会生成一个新对象，这个新对象的内部链接`[[Prototype]]`关联的是Foo.prototype对象。实际上我们并没有初始化一个类，也没有从“类”中复制任何一个行为到一个对象中，只是让两个对象互相关联。
  - **构造函数**：`Foo.prototype`默认有一个公有并且不可枚举的属性`.constructor`，这个属性引用的是对象关联的函数（本例中是Foo）。
    - 当且仅当使用new时，函数调用就会变成“构造函数调用”。new会劫持所有普通函数并用构造对象的形式来调用它。
    - `Foo.prototype.constructor`默认指向Foo，但实际上，`.constructor`引用是被委托给了`Foo.prototype`。
  - **原型继承**：在JavaScript中并不会将一个对象（“类”）复制到另一个对象（“实例”），只是将它们关联起来，这个机制被称为原型继承。但是继承意味着复制操作，js并不会复制，所以事实上“委托”这个术语描述会更加准确。
    - **创建关联对象**：需要调用`Object.create(..)`，它会凭空创建一个“新”对象并把新对象内部的`[[prototype]]`关联到指定的对象。缺点是需要抛弃旧对象，不能修改已有的默认对象，和轻微性能损失（抛弃的对象需要进行垃圾回收），但实际上比ES6及其之后的方法更短、可读性更高。
    - ES6前只能通过设置`.__proto__`属性来修改对象的`[[prototype]]`关联，`.__proto__`存在于内置的`Object.prototype`中，它引用了内部的`[[Prototype]]`对象，但无法兼容所有浏览器。ES6添加了`Object.setPrototypeOf(..)`这个标准并且可靠的修改关联的辅助函数。
    - **验证委托关联**：
      - ES5的标准方法：`Object.getPrototype(a) === Foo.prototype`
      - 非标准方法：`a.__proto__ === Foo.prototype`


### 行为委托
- XYZ通过`Object.create(..)`创建，它的`[[prototype]]`委托了Task对象。这种编码风格称为“对象关联”。
- 委托行为意味着某些对象（XYZ）在找不到属性或者方法引用时会把这个请求委托给另一个对象（Task）。
- 行为委托认为对象之间是兄弟关系，互相委托，而不是父类和子类的关系。JavaScript的`[[prototype]]`机制本质上就是行为委托机制。
- 我们可以选择在JavaScript中努力实现类机制，也可以拥抱更自然的`[[prototype]]`委托机制，**类并不适用于JavaScript**。
- **行为委托和类设计模式的不同之处**：
  - 通常来说，在`[[prototype]]`委托中最好把状态保存在委托者（XYZ、ABC）而不是委托目标（Task）上。
  - 尽量避免在`[[prototype]]`链的不同级别中使用相同的命名，否则就要用笨拙脆弱的语法来消除歧义。
  - `this.setID(ID)`，XYZ中没有这个方法名，会通过`[[prototype]]`委托关联到Task中找到这个方法，由于调用位置触发了this的隐式绑定规则，运行时this会绑定到XYZ，这正是我们想要的。
  - 使用类构造函数需要在同一个步骤中实现构造和初始化，对象关联则更好地支持关注分离原则，创建和初始化不需要合并为一个步骤。
  - 对象关联能让代码更加简洁、更具扩展性，简化了代码结构，用一种简单的设计实现了同样的功能。
- **互相委托（禁止）**：无法在两个或者两个以上互相（双向）委托的对象之间创建循环委托。如果引用了一个两边都不存在的属性或者方法，就会在`[[prototype]]`链上产生一个无限递归的循环。
- **对象关联风格的实现方法**：
  ```JavaScript
  Foo = {
  	init: function(who) {
  		this.me = who;
  	},
  	identify: function() {
  		return "I am " + this.me;
  	}
  };
  Bar = Object.create(Foo);
  Bar.speak = function() {
  	alert("Hello, " + this.identify() + ".");
  };

  var b1 = Object.create(Bar);
  b1.init("b1");
  var b2 = Object.create(Bar);
  b2.init("b2");

  b1.speak();
  b2.speak();
  ```

### ES6的class
  - class不是向JavaScript引入了一种新的“类”机制，而是现有`[[prototype]]`委托机制的一种语法糖。
  - class并不会像传统面向类的语言一样在声明时静态复制所有行为，如果修改或者替换了父“类”中的一个方法，子“类”的所有实例都会受到影响。
  - **优点**：
    - 语法更好看，不再引用杂乱的`.prototype`，不再需要使用`Object.create(..)`、`.__proto__`、`Object.setPrototypeOf(..)`;
    - 可以通过`super(..)`来实现多态，任何方法都可以引用原型链上层的同名方法，还可以解决构造函数无法互相应引用的问题；
    - class字面语法不能声明属性，只能声明方法，可以帮你避免犯错；
    - 可以通过`extends`很自然的扩展对象（子）类型，甚至是内置的对象（子）类型。
  - **缺点**：
    - 加深了过去二三十年对于JavaScript中“类”的误解，让`[[prototype]]`机制变得非常别扭；
    - class语法无法定义类成员属性，只能定义方法，如果为了追踪势力之间共享状态必须要这么做，只能使用丑陋的`.prototype`语法，这违背了class语法的本意；
    - 依然面临意外屏蔽的问题，如id属性屏蔽了id()方法；
    - 出于性能考虑，super是在声明时“静态”绑定的，根据应用方式的不同，super可能不会绑定到合适对象，这时需要用toMethod(..)来手动绑定。